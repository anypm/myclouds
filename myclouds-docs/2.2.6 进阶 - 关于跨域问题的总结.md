 > “跨域”是在前后端分离开发中必然会遇到的一个小问题，解决它并不困难，方法也很多。但它涉及的知识点还挺多，因此我觉得很有必要花点时间总结一下并给出myclouds处理跨域问题的优雅实践。

## 写在前面
关于“跨域”的一些基础知识这里就不讨论了，如果需要先充电的同学请移步这里看看：[跨域资源共享 CORS 详解](http://www.ruanyifeng.com/blog/2016/04/cors.html)。在这里，我就直接抛出问题：由于浏览器出于安全目的而制定的[“同源策略”](http://www.ruanyifeng.com/blog/2016/04/same-origin-policy.html)，导致Web页面通过XMLHttpRequest发起ajax请求的时候，如果访问非同源服务接口，则报错：`has been blocked by CORS policy: No 'Access-Control-Allow-Origin' header is present on the requested resource.`。
> 言外之意：“跨域”是针对网页中通过XMLHttpRequest对象发起的ajax请求才会出现的问题。在Android和IOS原生开发、测试工具调用、微服务与微服务之间的调用都是不存在跨域问题的。这点需要先厘清楚。

## 跨域问题常用解决办法
> 根据上述可知，其实无论是哪种办法，本质都是要往response的头信息中追加Access-Control-*相关的属性，只是实现方式不同而已。

1. ### 强撸
这是一种最简单粗暴也很有效的方法。即在能获取`HttpServletResponse`对象的上下文环境中，使用`response.addHeader();`方法来增加Access-Control-*相关属性。这种上下文有可能是具体的某个Controller方法，也可以是原生Servlet环境亦或是Struts、SpringMVC的过滤器、拦截器等。下面以SpringMVC的拦截器举例说明。
``` java
public class CrossInterceptor extends HandlerInterceptorAdapter {
	@Override
	public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler)
			throws Exception {
        if (request.getHeader(HttpHeaders.ORIGIN) != null) {
            response.addHeader("Access-Control-Allow-Origin", "*");
            response.addHeader("Access-Control-Allow-Credentials", "true");
            response.addHeader("Access-Control-Allow-Methods", "POST, GET, OPTIONS");
            response.addHeader("Access-Control-Max-Age", "86400");
        }
        return true;
    }
}  
```
> 拦截器需要在`WebMvcConfigurationSupport`的实现类中注册才会生效。这里就不展开了，具体注册方法请查阅本系列教程的另外一篇文章《进阶 - Web拦截器介绍与应用》。

1. ### 注解